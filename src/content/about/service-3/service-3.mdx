---

image: 'assets/service-3.png'
title: 'Dota-2'
description:  "Hunting down a flag-stealing ransomware group from WolvCTF 2023 with the power of OSINT—from Ethereum breadcrumbs to TF2 workshop maps."
date: 2022-03-17

---

## Intro

Hunting down a flag-stealing ransomware group from WolvCTF 2023 with the power of 
[OSINT—from Ethereum](https://ctftime.org/team/175828) breadcrumbs to TF2 workshop maps.<br/>
It is normal for flaws in concurrent code to hide. Simple tests often don’t expose them.
Indeed, they often hide during normal processing. They might show up once every few
hours, or days, or weeks! 
The reason that threading bugs can be infrequent, sporadic, and hard to repeat, is that
only a very few pathways out of the many thousands of possible pathways through a vulnerable section actually fail. So the probability that a failing pathway is taken can be startlingly low. This makes detection and debugging very difficult.
How might you increase your chances of catching such rare occurrences? You can
instrument your code and force it to run in different orderings by adding calls to methods
like Object.wait(), Object.sleep(), Object.yield() and Object.priority().
Each of these methods can affect the order of execution, thereby increasing the odds
of detecting a flaw. It’s better when broken code fails as early

---

